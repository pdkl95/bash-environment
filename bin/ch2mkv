#!/bin/bash

SELF="$0"
SELFNAME="$(basename "$SELF")"


#############################
### Customizable Settings ###
#############################

# ask for the prefix from the dispatcher
# tool if non was
: ${JOBLIST:=$(joblist --show-joblist-prefix)}

# to shut off the entire defered job sytem
# iand run 100% synchronously, set this to
# the empty string ""
#LOCAL_JOBLIST="${LOCAL_JOBLIST}/
# WARNIG: doing so could be dangerous!
# you *really* should verify the results
# first, before any of the destructive
# parts are procesed!
LOCAL_JOBLIST="${JOBLIST}/${SELFNAME}"

# ...but as a safety fail-safe, if the
# above setting is disables so we commit
# the changes immediately, we will still
# not *destroy* the original file unless
# you ALSO sert this varible to "always"
#
# On the event that we oneed to clobber
# the original file, but cannot because
# of this setting, processing will SIMPLLY
# TERMINATE, "successfully". It's up to
# you, then to handle the final "mv"!!!
CLOBBER_ORIGINAL=""

# set this to false, if you don't want
# all the ANSI excape codes on STDOUT
COLOR=true


###############################
### BEIGN parameter parsing ###
###############################

declare -i ret jobcount
declare orig orig_basename Tmp1 tmp2
declare dst dst_basename dst_dirname dst_real
declare defer_sh jobfile

cleanup_tmp() {
    local -i retval=${1:-1}
    if [ -f "$tmp1" ] ; then
        echo "cleaning up tempfile $tmp2" 1>&2
        rm -f -- "$tmp1"
    fi
    if [ -f "$tmp2" ] ; then
        echo "cleaning up tempfile $tmp2" 1>&2
        rm -f -- "$tmp2"
    fi
    exit $retval

    echo "${SELFNAME}: ${1:-Unknown Error}" 1>&2
    cleanup_tmp $retval
    exit $retval
}

die() {
    local -i ret="$1" ; shift
    echo -e ${@} 1>&2
    exit $ret
}

died_in() {
    ret=$?
    die $ret "ERROR - $1 failed with error code $ret"
}

if $COLOR ; then
    NC="\e[0m"
    prln()  { echo -e "\e[1;36m>>>\e[0;32m $@$NC"      ; }
    declare -i RR=0
    perr()  {
        if (( RR<1 )) ; then
            echo -e "\e[0;31m*\e[1;31m!\e[0;31m* $@$NC" 1>&2
        else
            echo -e "\e[1;31m!\e[0;31m*\e[1;31m! $@$NC" 1>&2
        fi
        (( RR=1-RR ))
    }
    pwarn() { perr "${NC}\e[1;33mWARN\e[0;2;33m:\e[1;34m $@" ; }
    pBAD()  { perr "\e[1;41;33m-=< \e[4;37mERROR\e[0m\e[41m \e[1;33m>=-$NC \e[1;35m$@" ; }
else
    prln()  { echo ">>> $@"      ; }
    perr()  { echo "!!! $@" 1>&2 ; }
    pwarn() { perr "WARN: $@" ; }
    pBAD()  { perr "*** ERROR: $@ ***" ; }
fi

# lets give at least a *chance* to interrupt before the we do
# destructive things like overitting the original files O.O
countdown_delay() {
    local -i x=4
    pwarn " // DELAY\t(${x}s) //"
    while (( x>0 )) ; do
        if $color ; then
            pwarn " //  \e[0;35m-* \e[1;36m$x\e[0;35m *-\e[1;34m\t     //"
        else
            pwarn " //  -* $x *-\t     //"
        fi
        sleep 1
        (( x=x-1 ))
    done
    pwarn " //  -* 0 *-\tGO!! //"
}

safe_make_tempfile() {
    tempfile --mode 0644 --prefix=ch2mkv_ --suffix=.mkv || died_in "tempfile"
}

cook_name() {
    sed -re 's/.*\///g' | tr ' .,-' '____' | tr -c -d 'a-zA-Z0-9_-' | sed -re 's/_+/_/g'
}

prepare_filenames() {
    [[ -f "$1" ]] || die "not a file: $file"

    orig="$(readlink -f "$1")"            || died_in "readlink"
    orig_basename="$(basename "${orig}")" || died_in "basename"

    dst_real="${orig%.*}.mkv"
    dst="${dst_real%.mkv}.MUST_BE_VERIFIED.mkv"
    dst_basename="$(basename "$dst")" || died_in "basename"
    dst_dirname="$(dirname "$dst")"   || died_in "dirname"

    tmp1="$(safe_make_tempfile)"
    tmp2="$(safe_make_tempfile)"
    trap cleanup_tmp SIGHUP SIGINT SIGTERM

    if [[ -n "${LOCAL_JOBLIST}" ]] ; then
        defer_sh="${dst_dirname}/.${dst_basename}.sh"

        # base job ID from the filename?
        jobfile="$(echo "${orig_basename%.*}" | cook_name)"
        # OR, this is safer:
        #jobfile="$(basename "$tmp2")" || died_in "basename"

        jobfile="${jobfile%.mkv}.job"
        jobfile="${LOCAL_JOBLIST}/${jobfile}"
        jobfile="$(readlink -f "$jobfile")" || died_in "readlink"
    fi
}

show_plan() {
    echo ">>>"
    echo ">>>  ChangeToMKV  *"
    echo ">> \\             /"
    echo ">   +-----------+"
    echo ">   |           |"
    echo "    |     input => $orig"
    echo "    |    output => $dst_real"
    echo ">   |           |"
    echo "\\>  |    (tmp1) => $tmp1"
    echo "--+ |    (tmp2) => $tmp2"
    echo "/>  |           |"
    echo ">   |   staging => ${dst}"
    echo "    |  defer_sh => ${defer_sh}"
    echo "    |   jobfile => ${jobfile}"
    echo ">   |           |"
    echo ">   +-----------+"
    echo ">> /             \\"
    echo ">>>               *"
    echo ">>>"
}

diffver() {
    local infocmd="mkvmerge --identify"
    if command hash mediainfo ; then
        infocmd="mediainfo"
    fi
    prln "Extracting metadata with: ${infocmd}"

    if command hash grc ; then
        grc diff -u <($infocmd "$1") <($infocmd "$2")
    else
        diff -u <($infocmd "$1") <($infocmd "$2")
    fi
}


run_the_conversion() {
    prln "remuxing with mkvmerge"
    echo mkvmerge -o "$tmp1" "$orig"
    mkvmerge -o "$tmp1" "$orig"

    echo mkclean --doctype 2 --remux --optimize "$tmp1" "$tmp2"
    mkclean --doctype 2 --remux --optimize "$tmp1" "$tmp2" || died_in "mkclean"
    touch -r "$orig" "$tmp2"

    diffver "$orig" "$tmp2"
    prln "validating the results..."

    local C=''
    if mkvalidator --no-warn --quiet "$tmp2" ; then
        $COLOR && C="\e[1;36m"
        prln "validation: ${C}PASS!"
    else
        $COLOR && C="\e[1;31m"
        prln "validation: ${C}FAIL!"
        # from sysexits.h
        #    #define EX_DATAERR 65  /* data format error */
        die 65 "mkvalidator rejected the conversion"
    fi

    prln "moving '$tmp2' -> '$dst'"
    mv -f -- "$tmp2" "$dst" || died_id "mv"
}

echo_exec() {
    echo echo "$@"
    echo "$@"
}

create_defered-finish_script() {
    prln "creating the finisher script for after inspection..."

    local pangodst="<span size='large' background='#000000' foreground='#08ff08' font_family='monospace'>${dst}</span>"

    local vtxt="Need to verify:\n\n${pangodst}\n\n"
    vtxt="${vtxt}In particular, check taht all tracks are present and correct,\n"
    vtxt="${vtxt}and watch for A/V sync problems such as audio drift!\n\n"
    vtxt="${vtxt}<i>Launch mplayer now?</i>"

    local qtxt="<span size='x-large' style='italic'>Did you verify the generated MKV?</span>\n\n"
    qtxt="${qtxt}${pangodst}\n\n"
    qtxt="${qtxt}<span size='large'>If so, should we <span underline='single' style='italic'>Commit</span> the changes,\n"
    qtxt="${qtxt}keeping the new MKV file by <b>OVERWRITING</b> the original?\n\n"
    qtxt="${qtxt}Otherwise, choose <span underline='low' style='italic'>Rollback</span> to revert back to the original,"
    qtxt="${qtxt} discarding all of the current changes.</span>"

    cat <<EOF > ${defer_sh}
#!/bin/bash

JOBFILE="${jobfile}"
SELF="${defer_sh}"
ORIG_NAME="${orig_basename}"
ORIGINAL="${orig}"
STAGING="${dst}"
TARGET="${dst_real}"

delete_self() {
    echo ">>>"
    echo ">>> Removing our entry in the pending queue:"
    $(echo_exec "rm" "-f" "\${JOBFILE}")

    echo ">>>"
    echo ">>> Removing ourself so no trash is left laying around:"
    $(echo_exec "rm" "-f" "\${SELF}")

    echo ">>>"
    echo ">>> Finished succssefully!"
    exit 0
}

setup() {
    if [[ -z "\${MPLAYER}" ]] ; then
        if command hash mplayer2 ; then
            MPLAYER="mplayer2"
        elif command hash mplayer ; then
                    MPLAYER="mplayer"
        else
            echo "!!! ERROR - mplayer not found!"
            exit 1
        fi
    fi

    if zenity --question --no-wrap --text="${vtxt}" --ok-label="Run MPlayer!" ; then
        echo ">>> Handing off to mplayer..."
        mplayer "\${STAGING}"
        echo ">>> ...back form mplayer!"
        exit 0
    else
        echo "!!! No verification was done!"
        exit 1
    fi
}

rollback() {
    echo ">>> Rolling back our changes, and leaving"
    echo ">>>     \${ORIGINAL}"
    echo ">>> alone as the untouched original."
    $(echo_exec "rm" "-f" "\${STAGING}")
    delete_self
}

commit() {
    echo ">>> MKV should be verified and checked."
    echo ">>>"
    echo ">>> Overiting the original file!!!"
    $(echo_exec "rm" "\${ORIGINAL}")
    $(echo_exec "mv" "\${STAGING}" "\${TARGET}")
    delete_self
}

print_ans_commit() {
    echo -e "Keep the new MKV, OVERWRITES the original"
}

print_ans_rollback() {
    echo -e "Undo all changes; keep origianl"
}

print_ans_cancel() {
    echo -e "Nevermind, just exit, no changes"
}

print_question() {
    echo -e "$qtxt"
}

filter_pango() {
    sed -re 's/<[^<>]+>//g'
}

usage_commands() {
    echo "COMMANDS:"
    cat "\$0" | sed -nre "\
/USEROPT\Wstart/,/USEROPT\Wend/ {
s/^\s*//
s/\).*;;//
s/^# USEROPT.*$//
s/^-/        -/
s/# /    /
p
}"
}

usage_job_specific() {
    echo "This job asks, the flowing about the"
    echo "initail --setup command:"
    echo
    print_question | filter_pango | fold -s -w 50 |  sed -re 's/^/    > /'
}

usage() {
    echo "Usage: \$0 <command>"
    echo
    echo "This is a job-specific helper tool, to continue a job"
    echo "that was suspended previously, and was created by:"
    echo "    $0"
    echo
    echo "In most cases, you should run this with the --setup"
    echo "command first and follow any instructions found there."
    echo "Afterwords, one of the two commands --rollback "
    echo "or --commit used be used to finalize everything."
    echo
    usage_job_specific
    echo
    usage_commands
}


parse_cmd() {
case \$1 in
    --gettext-commit)   print_ans_commit   ; exit 0 ;;
    --gettext-rollback) print_ans_rollback ; exit 0 ;;
    --gettext-cancel)   print_ans_cancel   ; exit 0 ;;
    --gettext-question) print_question     ; exit 0 ;;

# USEROPT+start
# Launches the tasks internal setup tool.
# Run this setu for this task; should ALWAYS
# be run before --rollback or --commit are used!
    -s | --setup) setup ;;

# Finalize the task - either delete the new or
# the old version, and then delete ourself to cleanup
    -r | --rollback) rollback ;;
    -c | --commit)   commit   ;;

# Show this help message
    -h | --help) usage ; exit 0 ;;
# USEROPT+end
    *)           usage ; exit 1 ;;
esac
}
parse_cmd "\$@"

# should never get here!!
exit 1

EOF

    chmod +x "${defer_sh}" || died_in "chmod"
    prln "script is ready!"
}

enqueue_deferment_globally() {
    mkdir -p "${LOCAL_JOBLIST}"

    prln "add to the must-be-verified queue..."
    cat <<EOF > ${jobfile}
JOB_ID="${SELFNAME}/verify/${orig_basename}"
JOB_BIN="${defer_sh}"
JOB_REQ_FILES="${defer_sh} ${dst} ${orig}"
JOB_CMD_SETUP="${defer_sh} --setup"
JOB_CMD_COMMIT="${defer_sh} --commit"
JOB_CMD_ROLLBACK="${defer_sh} --rollback"
JOB_ORIG_CREATOR="${SELFNAME}"
JOB_ORIG_PWD="${PWD}"
JOB_ORIG_USER_CMD="${SELFNAME} ${orig}"
JOB_DESC_NAME="${orig_basename}"
JOB_DESC_CATEGORY="${SELFNAME}-verify"
JOB_DESC_SHORT="Needs manual check: ${dst}"
JOB_DESC_FULL="Verify that\n    ${dst}\nwas properly generated from:\n    ${orig}\nNote things like A/V skew, missing tracks, etc"
EOF

    prln "successful logged this task at:"
    prln "  BEGIN: ${jobfile}"
    prln "----------------------------------------------------------"
    cat  "${jobfile}"
    prln "----------------------------------------------------------"
    prln "    END: ${jobfile}"

}

finalize_now() {
    prln "Commiting our changes permanently!"
    if [[ "${CLOBBER_ORIGINAL}" == "allowed" ]] ; then
        pwarn "Removing the original file!"
        countdown_delay
        rm "${orig}"              || died_in "rm"
        mv "${dst}" "${dst_real}" || died_in "mv"
        prln "Original file replaced, conversion is complete!"
    else
        perr "Both defered commands and unsafe overwrites are off"
        perr "We ahve no choice but to leave the file as-is."
        perr "You will need to verify and renameit manually!"
        perr "    semi-final file"
        perr "    -->  ${dst}"
    fi
}

#######################################
# entry-points from the command line

convert_to_mkv() {
    prepare_filenames "$1"
    show_plan
    run_the_conversion
    if [[ -n "${LOCAL_JOBLIST}" ]] ; then
        create_defered-finish_script
        enqueue_deferment_globally
    else
        finalize_now
    fi
}

run_multiple_jobs() {
    local final_retval=0
    prln "Multiple conversions requested:"
    for i in "$@"; do
        prln "  -> $i"
    done
    countdown_delay 2

    for arg in "$@" ; do
        "$SELF" "$arg"
        ret=$?
        case $ret in
            0)  # success; continue
                prln "Success!"
                ;;
            65) # validation error; we can
                # still continue with other files
                pwarn "A file failed to convert!"
                pwarn "Continuing anyhway..."
                final_retval=65
                ;;
            *)  # any other error, die
                die $ret "Received error: $ret! Shutting down."
        esac
    done
    exit $final_retval
}

dwim_find_things_to_convert() {
    pwarn "Received no files to convert!"
    pwarn "Assuming you mean the local directory tree!"
    pwarn "Kill it now if this is incorred!"
    countdown_delay
    prln "Searching with: find . -type f -name '*.avi' -o -name '*.mp4')"
    list="$(find . -type f -name '*.avi' -o -name '*.mp4')"
    run_multiple_jobs "$list"
}

#########################################
# launch jobs one at a time, recursively,
# so each one has it's own process, free
# of changes

jobcount=$#

if   (( jobcount<1 )) ; then
    dwim_find_things_to_convert
elif (( jobcount>1 )) ; then
    run_multiple_jobs "$@"
else
    if [[ "$1" =~ ^/.* ]] ; then
        convert_to_mkv "$1"
    else
        convert_to_mkv "${PWD}/$1"
    fi
fi


# EOF
