###################################
###  -=-  generic options  -=-  ###
###################################

##### first make sure the basic distro settings are loaded,
##### so we start with the current-OS's bindings

$include /etc/inputrc

##### options that are good everywhere
set bell-style none
set bind-tty-special-chars off
set blink-matching-paren on
set completion-ignore-case off
set completion-prefix-display-length 0
set completion-query-items 350
set convert-meta off
set echo-control-characters off
set editing-mode emacs
set enable-meta-key on
set expand-tilde off
set input-meta on
set keymap emacs
set mark-directories on
set mark-symlinked-directories on
set match-hidden-files off
set menu-complete-display-prefix off
set output-meta on
set page-completions off
set print-completions-horizontally off
set revert-all-at-newline on
set show-all-if-ambiguous on
set show-all-if-unmodified on
set skip-completed-text on
set visible-stats off


#############################
###  -=-  debugging  -=-  ###
#############################

##### dump binding tables
# <META>-d f
"\edf": dump-functions
# <META>-d v
"\edv": dump-variables
# <META>-d m
"\edm": dump-macros

##### ...and a way to fix drawing problems
# <META>-r
"\er": redraw-current-line

##### as a (probably redundant) sanity-check,
##### make sure some basic bindings are set properly
Return: accept-line
Control-_: undo
Control-u: universal-argument


################################
###  -==  text-killing  -=-  ###
################################

##### MUCH nicer than C-w and extends to "exit"
##### on an empty prompt like usual
Control-d: unix-filename-rubout
##### replace the old version with an alternate
##### form that only deletes word-characters
Control-w: unix-word-rubout
##### and give the meta variant yet another variation
# <META>-d
"\ed": shell-backword-kill-word

##### emacs-style line killing
Control-k: kill-line
##### with a shell-boundary version with meta
# <META>-k
"\ek": shell-kill-word
##### or on word-boundaries similar to forward-word
# <SHIFT>-<META>-k
"\eK": kill-word

##### put text on the kill buffer, without actually removing it
# <META>-w
"\ew": copy-region-as-kill

"\eW":

###########################
###  -=-  HISTORY  -=-  ###
###########################

##### prefix-search-as-you-go is much nicer, as it is often
##### the previous version of a given command that you want
##### to find in the history, even if it's not recent to the
##### current session. (works best with a VERY large and global
##### history log, so you can even pull commands from months
##### earlier, by just entering the prefix)
# UP
"\e[A": history-search-backward
# DOWN
"\e[B": history-search-forward
##### but keepe the standard prev/next version on <SHIFT>-
# <SHIFT>-UP
"\e[a": previous-history
# <SHIFT>-DOWN
"\e[b": next-history
##### incremental search of history
# <CONTROL>-UP
"\eOa": reverse-search-history
# <CONTROL>-DOWN
"\eOb": forward-search-history

##### the rest of the search tools are placed on page{up,down}
##### mainly because the keys aren't being used for anything else
# PAGEUP
"\e[5~": menu-complete-backward
# PAGEDOWN
"\e[6~": menu-complete
# <CONTROL>-PAGEUP
"\e[5^": non-incremental-reverse-search-history
# <CONTROL>-PAGEDOWN
"\e[6^": non-incremental-forward-search-history


###################################
###  -=-  cursor movement  -=-  ###
###################################

##### transposing words is far more useful, and therefore gets
##### the easier/nicer modifier key
Control-t: transpose-words
# <META>-t
"\et": transpose-chars

##### Searching like emacs
Control-s: character-search-backward
Control-r: character-search

##### word-by-word horizontal movement in the shell
##### by contiguous-letter/number segments
# <CONTROL>-RIGHT
"\eOc": forward-word
# <CONTROL>-LEFT
"\eOd": backward-word
##### by shell-argument boundaries
# <SHIFT>-RIGHT
"\e[c": shell-forward-word
# <SHIFT>-LEFT
"\e[d": shell-backward-word


#######################
###  -=-  etc  -=-  ###
#######################

##### make the menu button useful
# MENU
"\e[29~": menu-complete
# <SHIFT>-MENU
"\e[29$": menu-complete-backward

##### go to just before the first option of THIS command
##### that is, if you had alread typed
#####    echo foo bar baz
##### no matter the point is now, you end here
#####    echo _ foo bar baz
##### a single space is added to so the point is
##### _between_ whitespace.
##### This is very similar to the next macro, but stays
##### within the current command only, without touching
##### the history
# <META>-a
"\ea": "Oc "

##### load the previous comand, and edit
##### move to enter the FIRST option
##### example, if the previos command was:
#####     prog foo bar baz
##### Then pressin C-f would scroll up oneto the history
##### log to that commmand, and put the editing point
##### at the where the section marker indicates here:
#####     prog _ foo bar baz
##### A single extra space is also added such that the point
##### is now _between_ spaces and is read for something else
##### to be entered.
Control-f: "[AOc "


#########################
###  -=-  urxvt  -=-  ###
#########################

$if term=rxvt
    ##### HACK: using vertical tab as a 2nd ESC (HACKED URXVT ONLY!)
    #  non-working:
    #    "\033\033\001\015": "S-Return"
    #    "\033\033\003\015": "S-C-Return"
    #    "\033\033\004\015": "M-Return"
    #    "\033\033\006\015": "C-M-Return"
    #    "\033\033\001\011": "S-tab"
    #    "\033\033\006\011": "M-tab"

    #### RETURN ####
    # <shfit>-RETURN
    "\033\033\001\015": accept-line
    # <CONTROL>-RETURN
    "\033\033\002\015": operate-and-get-next
    # <SHIFT>-<META>-RETURN  ***WARNING: the shift ends up lost! ***
    "\033\033\004\015": accept-line
    # <SHIFT>-<CONTROL>-<META>-RETURN
    "\033\033\007\015": edit-and-execute-command
    # <SUPER>-RETURN
    "\033\033\012\015": operate-and-get-next
    # <ALT>-RETURN
    "\033\033\013\015": edit-and-execute-command
    # <HYPER>-RETURN
    "\033\033\014\015": "' >> echo '"

    #### TAB ####
    # <CONTROL>-TAB
    "\033\033\002\011": insert-completions

    #### 'k' ####
    # <SUPER>-k
    "\033\033\012\153": kill-region

    #### SPACE ####
    # <SHIFT>-SPACE
    "\033\033\001\040": " "
    # <CONTROL>-SPACE
    "\033\033\002\040": set-mark
    # <META>-SPACE
    "\033\033\004\040": " "
    # <SUPER>-SPACE
    "\033\033\012\040": magic-space
    # <ALT>-SPACE
    "\033\033\013\040": yank-last-arg
    # <HYPER>-SPACE
    "\033\033\014\040": yank-nth-arg

    #### ARROW KEYS ####

    ### transposing by shell-arg boundary
    # <META>-LEFT
    "\033\033\004\077\001": "\eOc\e[C\e \eOd\033\033\012\153\eOd\eOd"
    # <META>-RIGHT
    "\033\033\004\077\002": "\eOc\e \eOd\e[D\033\033\012\153\eOc"

    ### transposing by shell-arg boundary
    # <SUPER>-LEFT
    "\033\033\012\077\001": "\e[d\ek\e[d"
    # <SUPER>-RIGHT
    "\033\033\012\077\002": "\e[d\ek\e[c"

    ### double-quote wrapping/unwrapping ###
    # <ALT>-LEFT
    "\033\033\013\077\001": "\"\e[d\e\\ \"\eOD\eOD"
    # <ALT>-RIGHT
    "\033\033\013\077\002": "\e \e[c\"\eOC\"\eOC"
    # <SHIFT>-<ALT>-LEFT
    "\033\033\015\077\001": "\e\"\e[3~\e\"\e[3~"
    # <SHIFT>-<ALT>-RIGHT
    "\033\033\015\077\002": "\"\e[3~\"\e[3~"

    ### single-quote wrapping/unwrapping ###
    # <HYPER>-LEFT
    "\033\033\014\077\001": "'\e[d\e\\ '\eOD\eOD"
    # <HYPER>-RIGHT
    "\033\033\014\077\002": "\e \e[c'\eOC'\eOC"
    # <SHIFT>-<HYPER>-LEFT
    "\033\033\016\077\001": "\e'\e[3~\e'\e[3~"
    # <SHIFT>-<HYPER>-RIGHT
    "\033\033\016\077\002": "'\e[3~'\e[3~"

    #### DELETE ####

    # <SHIFT>-DELETE
    "\033\033\001\063\176": "\e[c\e[3~"
    # <CONTROL>-DELETE
    "\033\033\002\063\176": "\eOc\e[3~"
    # <SHIFT>-<CONTROL>-DELETE
    "\033\033\004\063\176": "\e[c\e[3~"
    # <SHIFT>-<META>-DELETE
    "\033\033\005\063\176": "\eOc\e[3~"
    # <SHIFT>-<CONTROL>-<META>-DELETE
    "\033\033\007\063\176": kill-whole-line
    # <SUPER>-DELETE
    "\033\033\012\063\176": delete-horizontal-space
    # <ALT>-DELETE
    "\033\033\013\063\176": copy-region-as-kill
    # <HYPER>-DELETE
    "\033\033\014\063\176": kill-region
$endif


########################
###  -=-  bash  -=-  ###
########################

$if Bash
    ##### cd up to the parent directory
    # <CONTROL>-p
    Control-p: "cd .."

    ##### remap keyboard macro recording to modern emacs style
    # <F3>
    "\e[13~": start-kbd-macro
    # <F4>
    "\e[14~": end-kbd-macro
    # <F5>
    "\e[15~": call-last-kbd-macro

    ##### dabbrev expansion experiment
    # <SHIFT>-<TAB>
    "\e[Z": dynamic-complete-history
    # <META>+h
    #"\eh": dabbrev-expand

    ##### insert ALL possible completions into current line
    #"\ei": insert-completions

    ##### if a History Expansion is ready when you hit space
    ##### apropriate expansion wil execute *immediately* with the
    ##### results automagically replacing the current command as
    ##### if you hasd typed again it from scratch
    # <space>
    #Space: magic-space

    ##### cd to whatever was named LAST in the previous command
    ##### for example, typing
    #####     cp -r /some/other/dir/ foo<RETURN><ALT>-l
    ##### will, after the copy is done, have you end up
    ##### in the newly copied "foo/" directory. It does an
    ##### 'ls' for you as ell once it gets there, as thhat's alost
    ##### certainly what you want to see first.
    # <ALT>-l
    #"\el": 'cd !$ ls -lh'

    ##### A shortcut for the previos shortcut, that presses
    ##### the <return> in the middle for your
    # <ALT>-L
    #"\eL": 'l'

    ##### reload the entire bash enviroment by running your
    ##### ~/.bashrc script again from the top
    ##### This compliments the builting C-xC-r to relaod *THIS* file
    # <CONTROL>-x <CONTROL>-b
    #"\C-x\C-b": ". ~/.bashrc"
$endif


######################
###  -=-  END  -=- ###
######################

# Local Variables:
# mode: sh
# sh-basic-offset: 4
# sh-shell: bash
# End:
